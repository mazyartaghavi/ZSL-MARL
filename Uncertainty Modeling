import torch
import torch.nn as nn
import torch.nn.functional as F

class BayesianBeliefUpdate(nn.Module):
    """
    This class performs a Bayesian belief update over the agent's understanding
    of the environment's dynamics, adapting its policy based on noisy or uncertain observations.
    """
    def __init__(self, input_dim, latent_dim=16):
        super(BayesianBeliefUpdate, self).__init__()
        # Latent space dimensions for belief
        self.latent_dim = latent_dim
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, latent_dim)
        )
        self.mu = nn.Linear(latent_dim, latent_dim)
        self.logvar = nn.Linear(latent_dim, latent_dim)
        self.policy_head = nn.Linear(latent_dim, 1)  # Continuous action space assumption

    def forward(self, observation):
        """
        Observation will go through an encoder and output a latent belief
        representing the agent's posterior belief about the state.
        """
        belief_latent = self.encoder(observation)
        mu = self.mu(belief_latent)
        logvar = self.logvar(belief_latent)
        std = torch.exp(0.5 * logvar)
        epsilon = torch.randn_like(std)
        z = mu + epsilon * std  # Stochastic sampling from the belief distribution
        action = self.policy_head(z)
        return action, mu, logvar

class BeliefPropagation(nn.Module):
    """
    Belief propagation layer for propagating agent beliefs across time-steps.
    Uses learned transition dynamics to propagate posterior beliefs over sequential states.
    """
    def __init__(self, belief_dim, hidden_dim=128):
        super(BeliefPropagation, self).__init__()
        self.fc1 = nn.Linear(belief_dim, hidden_dim)
        self.fc2 = nn.Linear(hidden_dim, belief_dim)
    
    def forward(self, belief, transition_model):
        """
        Update the belief using a transition model and previous belief.
        """
        x = F.relu(self.fc1(belief))
        updated_belief = self.fc2(x)
        return updated_belief + transition_model @ belief  # Incorporate learned transition model

class UncertaintyAwarePolicy(nn.Module):
    """
    Full uncertainty-aware policy module that integrates belief updates with Bayesian adaptation.
    """
    def __init__(self, state_dim, action_dim, latent_dim=16):
        super(UncertaintyAwarePolicy, self).__init__()
        self.bayesian_update = BayesianBeliefUpdate(state_dim, latent_dim)
        self.belief_propagation = BeliefPropagation(latent_dim)
        self.action_dim = action_dim

    def forward(self, state, transition_model):
        """
        Perform Bayesian belief update and propagate the belief forward through time.
        """
        action, mu, logvar = self.bayesian_update(state)
        updated_belief = self.belief_propagation(mu, transition_model)
        return action, updated_belief, mu, logvar

    def compute_uncertainty(self, logvar):
        """
        Compute uncertainty based on the log variance from the Bayesian belief model.
        """
        return torch.mean(torch.exp(logvar))  # Uncertainty is proportional to exp(logvar)


